### 4.5~4.11 实现中要解决的问题

#### 4.5 嵌套的 effect 与 effect 栈

要解决嵌套的 effect 栈，方法：副作用函数栈 effectStack，在副作用函数执行时，将当前副作用函数压入栈中，待副作用函数执行完毕后将其从栈中弹出，并始终让 activeEffect 指向栈顶的副作用函数。这样就能做到一个响应式数据只会收集直接读取其值的副作用函数，而不会出现互相影响的情况。

#### 4.6 避免无限递归循环

- 场景：副作用函数内执行自增操作 obj.foo++时（obj.foo = obj.foo + 1;）首先这是在执行副作用函数的过程，然而加 1 后再赋值给 obj.foo，此时会触发 trigger 操作，即把“桶”中的副作用函数取出并执行。但问题是该副作用函数正在执行中，还没有执行完毕，就要开始下一次的执行。这样会导致无限递归地调用自己，于是就产生了栈溢出。
- 解决方法：在 trigger 动作发生时增加守卫条件：如果 trigger 触发执行的副作用函数与当前正在执行的副作用函数相同，则不触发执行。

#### 4.7 调度执行

场景：用户可以在调度器 scheduler ，有了调度函数，我们在 trigger 函数中触发副作用函数重新执行时，就可以直接调用用户传递的调度器函数，从而把控制权交给用户。

通过调度器还可以做到控制它的执行次数，对于多次连续操作时可以跳过中间过渡状态。
实现：关键在于事件循环的任务队列，我不理解为什么不会在执行完

```javascript
// 在微任务队列中刷新 jobQueue 队列
p.then(() => {
  jobQueue.forEach((job) => job());
}).finally(() => {
  // 结束后重置 isFlushing
  isFlushing = false;
});
```

上面的副作用函数之后才 obj.foo++，这样就又调用一次 flushJob 函数，原因就是在于我忘记了事件循环事件的执行顺序，先执行同步代码->才执行异步代码，而上面的代码是模拟了微任务队列，在同步代码全部执行完毕之后才会在微任务队列栈中拿出 p.then(() => { jobQueue.forEach(job => job()) })进行执行，所以此时 obj.foo 的值已经是 3，直接跳过了中间状态 2.

这里还利用了 set 的去重能力，连续地执行两次 scheduler 调度函数，这意味着同一个副作用函数会被 jobQueue.add(fn) 语句添加两次，但由于 Set 数据结构的去重能力，最终 jobQueue 中只会有一项，即当前副作用函数，加上 isFlushing 标志，所以最终实现的效果就是，flushJob 函数中的 p.then()只会执行一次,jobQueue 中也只会有一个副作用函数。

#### 4.8 计算属性 computed 与 lazy

计算属性：实现了懒执行的副作用函数的执行结果

```javascript
function computed(getter) {
  // 把 getter 作为副作用函数，创建一个 lazy 的 effect
  const effectFn = effect(getter, {
    lazy: true,
  });

  const obj = {
    // 当读取 value 时才执行 effectFn
    get value() {
      return effectFn();
    },
  };

  // computed函数返回的其实是一个对象，该对象的 value 属性是一个访问器属性，只有当读取 value 的值时，才会执行 effectFn 并将其结果作为返回值返回。
  return obj;
}
```

computed 函数返回的其实是一个对象，该对象的 value 属性是一个访问器属性，只有当读取 value 的值时，才会执行 effectFn 并将其结果作为返回值返回。
